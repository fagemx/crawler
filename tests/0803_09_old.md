#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Reader內容解析器 - 從Jina Reader返回的markdown中提取關鍵數據
"""

import re
import requests
from typing import Dict, Optional, List
import json

class ThreadsReaderParser:
    """Threads貼文Reader解析器"""
    
    def __init__(self, reader_base_url: str = "http://localhost:8880"):
        self.reader_base_url = reader_base_url
    
    def fetch_content(self, post_url: str) -> str:
        """從Reader服務獲取內容"""
        reader_url = f"{self.reader_base_url}/{post_url}"
        try:
            response = requests.get(reader_url, timeout=30)
            response.raise_for_status()
            return response.text
        except Exception as e:
            print(f"❌ 獲取內容失敗: {e}")
            return ""
    
    def extract_post_content(self, markdown_content: str) -> Optional[str]:
        """提取貼文內容"""
        lines = markdown_content.split('\n')
        
        # 方法1: 查找第一段正文內容（在===分隔符之前）
        content_lines = []
        in_content = False
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            # 跳過標題和URL行
            if line.startswith("Title:") or line.startswith("URL Source:") or line.startswith("Markdown Content:"):
                continue
                
            # 如果遇到分隔符，停止
            if "===============" in line or "---" in line:
                break
                
            # 如果是貼文內容（不是連結、不是按鈕文字）
            if not line.startswith("[") and not line.startswith("!") and len(line) > 10:
                content_lines.append(line)
                if len(content_lines) >= 3:  # 取前幾行作為內容
                    break
        
        return ' '.join(content_lines) if content_lines else None
    
    def extract_views_count(self, markdown_content: str) -> Optional[str]:
        """提取觀看數"""
        # 查找包含"views"的行
        patterns = [
            r'(\d+(?:\.\d+)?[KMB]?)\s*views',
            r'Thread.*?(\d+(?:\.\d+)?[KMB]?)\s*views',
            r'(\d+(?:,\d+)*)\s*views'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, markdown_content, re.IGNORECASE)
            if match:
                return f"{match.group(1)} views"
        
        return None
    
    def extract_likes_count(self, markdown_content: str) -> Optional[str]:
        """提取按讚數 - 多種格式支援"""
        lines = markdown_content.split('\n')
        
        # 方法1: 查找"Like"標籤後的數字（舊格式）
        for i, line in enumerate(lines):
            if line.strip() == "Like" and i + 2 < len(lines):
                next_line = lines[i + 2].strip()
                if re.match(r'^\d+(?:\.\d+)?[KMB]?$', next_line):
                    return next_line
        
        # 方法2: 新格式 - 從數字序列中取第一個
        numbers = self.extract_engagement_numbers(markdown_content)
        if len(numbers) >= 1:
            return numbers[0]
        
        # 方法3: 查找"like"相關模式
        like_patterns = [
            r'Like\s*\n\s*(\d+(?:\.\d+)?[KMB]?)',
            r'(\d+(?:\.\d+)?[KMB]?)\s*(?:likes?|👍|❤️)'
        ]
        
        for pattern in like_patterns:
            match = re.search(pattern, markdown_content, re.MULTILINE | re.IGNORECASE)
            if match:
                return match.group(1)
        
        return None
    
    def extract_engagement_numbers(self, markdown_content: str) -> List[str]:
        """提取所有統計數字序列（按讚、留言、轉發、分享）"""
        lines = markdown_content.split('\n')
        
        # 策略1: 查找貼文內容後的第一個圖片，然後提取後續數字
        for i, line in enumerate(lines):
            stripped = line.strip()
            # 找到貼文圖片（通常在Translate之後）
            if stripped.startswith('![Image') and not 'profile picture' in stripped:
                numbers = []
                # 在這個圖片後查找連續的數字
                for j in range(i + 1, min(i + 20, len(lines))):
                    candidate = lines[j].strip()
                    if re.match(r'^\d+(?:\.\d+)?[KMB]?$', candidate):
                        numbers.append(candidate)
                    elif candidate and not re.match(r'^\d+(?:\.\d+)?[KMB]?$', candidate) and candidate != "Pinned":
                        # 遇到非數字行（但跳過Pinned），停止收集
                        break
                
                # 如果找到了數字序列，返回
                if len(numbers) >= 3:
                    return numbers
        
        # 策略2: 如果策略1失敗，查找任何連續的數字序列
        all_numbers = []
        for i, line in enumerate(lines):
            stripped = line.strip()
            if re.match(r'^\d+(?:\.\d+)?[KMB]?$', stripped):
                # 檢查前後文，確保這是統計數字
                context_valid = False
                # 檢查前面10行是否有圖片或貼文內容
                for k in range(max(0, i-10), i):
                    if "![Image" in lines[k] or "Translate" in lines[k]:
                        context_valid = True
                        break
                
                if context_valid:
                    all_numbers.append(stripped)
        
        # 如果找到4個或更多數字，取前4個
        if len(all_numbers) >= 4:
            return all_numbers[:4]
        elif len(all_numbers) >= 3:
            return all_numbers[:3]
        
        return all_numbers
    
    def extract_comments_count(self, markdown_content: str) -> Optional[str]:
        """提取留言數"""
        lines = markdown_content.split('\n')
        
        # 方法1: 舊格式 - 查找Comment標籤
        for i, line in enumerate(lines):
            if line.strip() == "Comment" and i + 2 < len(lines):
                next_line = lines[i + 2].strip()
                if re.match(r'^\d+(?:\.\d+)?[KMB]?$', next_line):
                    return next_line
        
        # 方法2: 新格式 - 從數字序列中取第二個
        numbers = self.extract_engagement_numbers(markdown_content)
        if len(numbers) >= 2:
            return numbers[1]
        
        return None
    
    def extract_reposts_count(self, markdown_content: str) -> Optional[str]:
        """提取轉發數"""
        lines = markdown_content.split('\n')
        
        # 方法1: 舊格式 - 查找Repost標籤
        for i, line in enumerate(lines):
            if line.strip() == "Repost" and i + 2 < len(lines):
                next_line = lines[i + 2].strip()
                if re.match(r'^\d+(?:\.\d+)?[KMB]?$', next_line):
                    return next_line
        
        # 方法2: 新格式 - 從數字序列中取第三個
        numbers = self.extract_engagement_numbers(markdown_content)
        if len(numbers) >= 3:
            return numbers[2]
        
        return None
    
    def extract_shares_count(self, markdown_content: str) -> Optional[str]:
        """提取分享數"""
        lines = markdown_content.split('\n')
        
        # 方法1: 舊格式 - 查找Share標籤
        for i, line in enumerate(lines):
            if line.strip() == "Share" and i + 2 < len(lines):
                next_line = lines[i + 2].strip()
                if re.match(r'^\d+(?:\.\d+)?[KMB]?$', next_line):
                    return next_line
        
        # 方法2: 新格式 - 從數字序列中取第四個
        numbers = self.extract_engagement_numbers(markdown_content)
        if len(numbers) >= 4:
            return numbers[3]
        
        return None
    
    def parse_post(self, post_url: str) -> Dict:
        """解析單篇貼文，返回結構化數據"""
        print(f"🎯 開始解析貼文: {post_url}")
        
        # 獲取內容
        content = self.fetch_content(post_url)
        if not content:
            return {"error": "無法獲取內容"}
        
        print(f"📄 獲取到 {len(content)} 字符的內容")
        
        # 提取各項數據
        result = {
            "url": post_url,
            "content": self.extract_post_content(content),
            "views": self.extract_views_count(content),
            "likes": self.extract_likes_count(content),
            "comments": self.extract_comments_count(content),
            "reposts": self.extract_reposts_count(content),
            "shares": self.extract_shares_count(content),
            "raw_length": len(content)
        }
        
        return result
    
    def debug_content(self, post_url: str, save_raw: bool = True):
        """調試模式：顯示原始內容以便分析"""
        content = self.fetch_content(post_url)
        if not content:
            return
        
        print("🔍 原始內容分析:")
        print("=" * 50)
        
        lines = content.split('\n')
        for i, line in enumerate(lines[:30]):  # 只顯示前30行
            print(f"{i+1:2d}: {line}")
        
        print(f"\n... (總共 {len(lines)} 行)")
        
        if save_raw:
            filename = f"reader_raw_content_{post_url.split('/')[-1]}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"💾 原始內容已保存到: {filename}")

def main():
    """測試解析器"""
    parser = ThreadsReaderParser()
    
    # 測試貼文
    test_url = "https://www.threads.com/@ttshow.tw/post/DMfOVeqSkM5"
    
    print("🧪 測試Reader解析器")
    print("=" * 50)
    
    # 調試模式：查看原始內容
    print("📋 調試模式 - 查看原始內容:")
    parser.debug_content(test_url)
    
    print("\n" + "=" * 50)
    
    # 解析模式：提取結構化數據
    print("📊 解析模式 - 提取結構化數據:")
    result = parser.parse_post(test_url)
    
    print(f"📝 貼文內容: {result.get('content', 'N/A')}")
    print(f"👁️ 觀看數: {result.get('views', 'N/A')}")
    print(f"👍 按讚數: {result.get('likes', 'N/A')}")
    print(f"💬 留言數: {result.get('comments', 'N/A')}")
    print(f"🔄 轉發數: {result.get('reposts', 'N/A')}")
    print(f"📤 分享數: {result.get('shares', 'N/A')}")
    print(f"📄 原始長度: {result.get('raw_length', 0)} 字符")
    
    # 調試：顯示找到的數字序列
    content = parser.fetch_content(test_url)
    numbers = parser.extract_engagement_numbers(content)
    print(f"🔍 找到的數字序列: {numbers}")
    
    # 保存結果
    with open('reader_parse_result.json', 'w', encoding='utf-8') as f:
        json.dump(result, f, ensure_ascii=False, indent=2)
    
    print("💾 解析結果已保存到: reader_parse_result.json")

if __name__ == "__main__":
    main()