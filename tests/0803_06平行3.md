å¥½å•é¡Œï¼è®“æˆ‘å…ˆæª¢æŸ¥ç¾åœ¨çš„Orchestratorå¯¦éš›åœ¨åšä»€éº¼ï¼š
Read file: agents/orchestrator/main.py

Ran tool

Ran tool

Read file: agents/playwright_crawler/main.py

Ran tool

å¥½å•é¡Œï¼æª¢æŸ¥äº†ä»£ç¢¼å¾Œæˆ‘ç™¼ç¾ï¼š

## ğŸ” **ç¾åœ¨çš„Orchestratorå¯¦éš›åœ¨åšä»€éº¼**
Read file: agents/orchestrator/main.py

Read file: agents/playwright_crawler/main.py

## âœ… **ä½ çš„å›°æƒ‘æ˜¯å°çš„ï¼**

æª¢æŸ¥ä»£ç¢¼å¾Œç™¼ç¾ï¼š

### **ç¾åœ¨çš„Orchestratorè·è²¬**
```python
# agents/orchestrator/main.py - å¯¦éš›åŠŸèƒ½
1. èª¿ç”¨æ¾„æ¸…ä»£ç† (Clarification Agent)    # ç”Ÿæˆæ¾„æ¸…å•å·
2. èª¿ç”¨è¡¨å–®API (Form API)              # å­˜å„²ç”¨æˆ¶å›ç­”  
3. èª¿ç”¨å…§å®¹å¯«æ‰‹ (Content Writer)        # ç”Ÿæˆç¤¾åª’å…§å®¹

# å®Œå…¨æ˜¯å…§å®¹ç”Ÿæˆçš„å·¥ä½œæµç¨‹ï¼èˆ‡çˆ¬èŸ²ç„¡é—œ
```

### **Playwright Crawleræ˜¯ç¨ç«‹æœå‹™**
```python
# agents/playwright_crawler/main.py - ç¨ç«‹API
@app.post("/v1/playwright/crawl")  # ç›´æ¥æ¥æ”¶çˆ¬èŸ²è«‹æ±‚
# ä¸éœ€è¦é€šéOrchestratorèª¿ç”¨
```

---

## ğŸ—ï¸ **æ­£ç¢ºçš„æ¶æ§‹æ‡‰è©²æ˜¯**

### **ç¾ç‹€ï¼ˆå…©å€‹ç¨ç«‹æ¥­å‹™ï¼‰**
```
æ¥­å‹™Aï¼šæ•¸æ“šçˆ¬å–æµç¨‹
ç”¨æˆ¶ â†’ Playwright Crawler API â†’ è¿”å›æ•¸æ“š

æ¥­å‹™Bï¼šå…§å®¹ç”Ÿæˆæµç¨‹  
ç”¨æˆ¶ â†’ Orchestrator â†’ æ¾„æ¸… â†’ è¡¨å–® â†’ å…§å®¹ç”Ÿæˆ
```

### **ä½ çš„Readeræ–¹æ¡ˆä¸éœ€è¦Orchestratorï¼**
```
å¿«é€Ÿçˆ¬å–æµç¨‹ï¼š
ç”¨æˆ¶ â†’ Reader Service â†’ è¿”å›Markdownå…§å®¹

å®Œæ•´çˆ¬å–æµç¨‹ï¼š
ç”¨æˆ¶ â†’ Playwright Crawler â†’ è¿”å›å®Œæ•´æ•¸æ“š

é›™è»Œä¸¦è¡Œï¼š
ç”¨æˆ¶ â†’ [Reader + Playwright Crawler] â†’ åˆä½µçµæœ
```

---

## ğŸ”§ **é‡æ–°è¨­è¨ˆçš„ç°¡åŒ–æ¶æ§‹**

### **æ–¹æ¡ˆ1ï¼šå®Œå…¨ç¨ç«‹ï¼ˆæ¨è–¦ï¼‰**
```yaml
# æ–°å¢åˆ° docker-compose.yml
reader-service:                    # ç«¯å£ 8880
â”œâ”€â”€ reader-1, reader-2 + nginx LB
â””â”€â”€ ç›´æ¥å°å¤–æä¾›API

# ç¾æœ‰æœå‹™ä¿æŒä¸è®Š
playwright-crawler:               # ç«¯å£ 8006  
â”œâ”€â”€ /v1/playwright/crawl
â””â”€â”€ å®Œæ•´DOMçˆ¬å–

# å‰ç«¯å¯ä»¥é¸æ“‡èª¿ç”¨ï¼š
# - Reader Service (å¿«é€Ÿ)
# - Playwright Crawler (å®Œæ•´)  
# - æˆ–è€…åŒæ™‚èª¿ç”¨å…©è€…
```

### **æ–¹æ¡ˆ2ï¼šç°¡å–®å”èª¿å™¨ï¼ˆå¯é¸ï¼‰**
```python
# æ–°å»º services/crawl_coordinator/
@app.post("/crawl/{account}")
async def unified_crawl(account: str, mode: str):
    if mode == "fast":
        return await call_reader_service(account)
    elif mode == "full":  
        return await call_playwright_crawler(account)
    elif mode == "hybrid":
        # ä¸¦è¡Œèª¿ç”¨ï¼Œåˆä½µçµæœ
        reader_task = call_reader_service(account)
        crawler_task = call_playwright_crawler(account)
        return await merge_results(reader_task, crawler_task)
```

---

## ğŸ’¡ **å¯¦æ–½å»ºè­°**

### **æœ€ç°¡å–®çš„æ–¹æ¡ˆï¼ˆç«‹å³å¯è¡Œï¼‰**
```bash
# 1. æ·»åŠ Readeræœå‹™åˆ°docker-compose.yml
# 2. å‰ç«¯ç›´æ¥èª¿ç”¨å…©å€‹APIï¼š

# å¿«é€Ÿé è¦½
curl "http://localhost:8880/https://threads.com/@0612ray/post/xxx"

# å®Œæ•´æ•¸æ“š  
curl -X POST "http://localhost:8006/v1/playwright/crawl" \
     -d '{"username":"0612ray","max_posts":5}'

# ç”¨æˆ¶åœ¨UIé¸æ“‡è¦å“ªç¨®æ¨¡å¼
```

### **é€²éšæ–¹æ¡ˆï¼ˆå¦‚æœéœ€è¦çµ±ä¸€å…¥å£ï¼‰**
```python
# å‰µå»ºä¸€å€‹è¼•é‡ç´šè·¯ç”±æœå‹™
@app.post("/api/crawl")
async def route_crawl(account: str, mode: str, max_posts: int):
    if mode == "reader":
        urls = await get_account_urls(account, max_posts)  
        return await batch_call_reader(urls)
    else:
        return await call_playwright_crawler(account, max_posts)
```

---

## ğŸ¯ **çµè«–**

**ä½ æ˜¯å°çš„ï¼Readerå®Œå…¨ä¸éœ€è¦Orchestratorã€‚**

å»ºè­°çš„å¯¦æ–½é †åºï¼š
1. âœ… **ç›´æ¥æ·»åŠ Readeræœå‹™**ï¼ˆæœ€ç°¡å–®ï¼‰
2. âœ… **å‰ç«¯æä¾›æ¨¡å¼é¸æ“‡**ï¼ˆå¿«é€Ÿ vs å®Œæ•´ï¼‰
3. ğŸ”„ **å¯é¸ï¼šå‰µå»ºç°¡å–®çš„çµ±ä¸€API**ï¼ˆå¦‚æœéœ€è¦ï¼‰

**ç¾åœ¨çš„Orchestratorç¹¼çºŒè² è²¬å…§å®¹ç”Ÿæˆï¼Œä¸è¦å‹•å®ƒã€‚Readerä½œç‚ºç¨ç«‹æœå‹™æ·»åŠ å³å¯ã€‚**

**éœ€è¦æˆ‘é–‹å§‹å¯¦æ–½Readeræœå‹™çš„docker-composeé…ç½®å—ï¼Ÿ**

#####

å¥½å•é¡Œï¼è®“æˆ‘å…ˆæª¢æŸ¥ç¾åœ¨çš„æ­·å²è¨˜éŒ„å’Œç‹€æ…‹ç®¡ç†æ©Ÿåˆ¶ï¼š
Read file: common/history.py

Read file: common/history.py

Read file: common/models.py

Ran tool

Read file: scripts/init-db.sql

## ğŸ” **ç¾æœ‰æ­·å²è¨˜éŒ„å’Œç‹€æ…‹ç®¡ç†åˆ†æ**

### âœ… **ç¾åœ¨æœ‰çš„æ©Ÿåˆ¶**

```python
# 1. æ­·å²è¨˜éŒ„æª¢æŸ¥
get_existing_post_ids(username) â†’ Set[str]  # è¿”å›å·²çˆ¬å–çš„post_idé›†åˆ

# 2. çˆ¬å–ç‹€æ…‹è·Ÿè¸ª
crawl_stateè¡¨ï¼š
â”œâ”€â”€ username (ä¸»éµ)
â”œâ”€â”€ latest_post_id        # æœ€æ–°è²¼æ–‡IDï¼Œæ”¯æ´å¢é‡çˆ¬å–
â”œâ”€â”€ total_crawled         # ç¸½çˆ¬å–æ•¸é‡
â””â”€â”€ last_crawl_at         # æœ€å¾Œçˆ¬å–æ™‚é–“

# 3. è²¼æ–‡ç‹€æ…‹æ¨™è¨˜
PostMetricsæ¨¡å‹ï¼š
â”œâ”€â”€ source               # æ•¸æ“šä¾†æº: "apify", "jina", "vision"
â”œâ”€â”€ processing_stage     # è™•ç†éšæ®µ: "initial", "details_filled_hybrid", "views_filled"  
â””â”€â”€ is_complete         # æ˜¯å¦å®Œæ•´: True/False
```

### âš ï¸ **ç›®å‰ä¸è¶³ä¹‹è™•**

```python
# ç„¡æ³•å€åˆ†é›™è»Œç‹€æ…‹ï¼š
# âŒ ä¸çŸ¥é“é€™ç¯‡è²¼æ–‡æ˜¯å¦è¢«Readerè™•ç†é
# âŒ ä¸çŸ¥é“é€™ç¯‡è²¼æ–‡æ˜¯å¦è¢«DOMå®Œæ•´çˆ¬å–é  
# âŒ ç„¡æ³•åˆ¤æ–·éœ€è¦è£œå……å“ªç¨®é¡å‹çš„æ•¸æ“š
```

---

## ğŸ¯ **ä½ çš„UIéœ€æ±‚åˆ†æ**

### **éœ€è¦æ”¯æ´çš„ç‹€æ…‹æ¨™è¨˜**

```typescript
interface PostStatus {
  url: string;
  post_id: string;
  
  // é›™è»Œè™•ç†ç‹€æ…‹
  reader_status: 'pending' | 'success' | 'failed' | 'skipped';    // æ¨™è¨˜A
  dom_status: 'pending' | 'success' | 'failed' | 'skipped';       // æ¨™è¨˜B
  
  // æ•¸æ“šå®Œæ•´æ€§
  has_content: boolean;        // æœ‰å…§å®¹
  has_metrics: boolean;        // æœ‰äº’å‹•æ•¸æ“š
  has_media: boolean;          // æœ‰åœ–ç‰‡/å½±ç‰‡
  
  // æ™‚é–“æˆ³
  reader_processed_at?: Date;
  dom_processed_at?: Date;
  
  // å„ªå…ˆç´š/éœ€æ±‚
  needs_reader: boolean;       // éœ€è¦Readerè™•ç†
  needs_dom: boolean;          // éœ€è¦DOMå®Œæ•´çˆ¬å–
}
```

### **UIè¨­è¨ˆå»ºè­°**

```jsx
// è²¼æ–‡åˆ—è¡¨ç•Œé¢
const PostList = ({ username }) => {
  const posts = usePostStatus(username);
  
  return (
    <div>
      <UserSelector onChange={setUsername} />
      <PostStats posts={posts} />  {/* çµ±è¨ˆæ‘˜è¦ */}
      
      {posts.map(post => (
        <PostCard key={post.post_id} post={post}>
          {/* ç‹€æ…‹æŒ‡ç¤ºå™¨ */}
          <StatusBadge type="reader" status={post.reader_status} />
          <StatusBadge type="dom" status={post.dom_status} />
          
          {/* æ“ä½œæŒ‰éˆ• */}
          <ActionButtons post={post} />
        </PostCard>
      ))}
    </div>
  );
};
```

---

## ğŸ”§ **éœ€è¦å¯¦æ–½çš„æ”¹é€²**

### **1. æ“´å±•æ•¸æ“šæ¨¡å‹**

```python
# common/models.py æ–°å¢æ¬„ä½
class PostMetrics(BaseModel):
    # ... ç¾æœ‰æ¬„ä½ ...
    
    # æ–°å¢ï¼šé›™è»Œè™•ç†ç‹€æ…‹
    reader_status: str = Field("pending", description="Readerè™•ç†ç‹€æ…‹")
    dom_status: str = Field("pending", description="DOMçˆ¬å–ç‹€æ…‹")
    reader_processed_at: Optional[datetime] = None
    dom_processed_at: Optional[datetime] = None
    
    # æ–°å¢ï¼šæ•¸æ“šä¾†æºè¿½è¹¤
    data_sources: List[str] = Field(default_factory=list, description="æ•¸æ“šä¾†æºåˆ—è¡¨")
    
    def is_reader_complete(self) -> bool:
        return self.reader_status == "success" and bool(self.content)
    
    def is_dom_complete(self) -> bool:
        return self.dom_status == "success" and self.is_complete
        
    def needs_processing(self) -> dict:
        return {
            "needs_reader": not self.is_reader_complete(),
            "needs_dom": not self.is_dom_complete()
        }
```

### **2. æ“´å±•æ­·å²è¨˜éŒ„ç®¡ç†**

```python
# common/history.py æ–°å¢æ–¹æ³•
class CrawlHistoryDAO:
    
    async def get_posts_status(self, username: str) -> List[Dict]:
        """ç²å–ç”¨æˆ¶æ‰€æœ‰è²¼æ–‡çš„ç‹€æ…‹æ‘˜è¦"""
        async with self.db_client.get_connection() as conn:
            result = await conn.fetch("""
                SELECT 
                    post_id, url, 
                    reader_status, dom_status,
                    reader_processed_at, dom_processed_at,
                    content IS NOT NULL as has_content,
                    views_count IS NOT NULL as has_metrics,
                    (images != '[]' OR videos != '[]') as has_media
                FROM post_metrics_sql 
                WHERE username = $1
                ORDER BY created_at DESC
            """, username)
            return [dict(row) for row in result]
    
    async def get_processing_needs(self, username: str) -> Dict:
        """åˆ†æç”¨æˆ¶çš„è™•ç†éœ€æ±‚"""
        async with self.db_client.get_connection() as conn:
            result = await conn.fetchrow("""
                SELECT 
                    COUNT(*) as total_posts,
                    COUNT(CASE WHEN reader_status = 'success' THEN 1 END) as reader_complete,
                    COUNT(CASE WHEN dom_status = 'success' THEN 1 END) as dom_complete,
                    COUNT(CASE WHEN reader_status = 'pending' THEN 1 END) as needs_reader,
                    COUNT(CASE WHEN dom_status = 'pending' THEN 1 END) as needs_dom
                FROM post_metrics_sql 
                WHERE username = $1
            """, username)
            return dict(result) if result else {}
```

### **3. URLæ”¶é›†å™¨å¢å¼·**

```python
# ä¿®æ”¹ agents/playwright_crawler/main.py
@app.get("/urls/{username}")
async def get_user_urls(username: str, max_posts: int = 50):
    """ç²å–ç”¨æˆ¶è²¼æ–‡URLsï¼Œé™„å¸¶è™•ç†ç‹€æ…‹"""
    
    # æ”¶é›†URLs
    logic = PlaywrightLogic()
    urls = await logic.fetch_urls_only(username, max_posts)
    
    # æª¢æŸ¥è™•ç†ç‹€æ…‹
    history = CrawlHistoryDAO()
    existing_status = await history.get_posts_status(username)
    status_map = {item['url']: item for item in existing_status}
    
    # åˆä½µçµæœ
    url_status = []
    for url in urls:
        if url in status_map:
            url_status.append(status_map[url])
        else:
            url_status.append({
                'url': url,
                'post_id': extract_post_id(url),
                'reader_status': 'pending',
                'dom_status': 'pending',
                'needs_reader': True,
                'needs_dom': True
            })
    
    return {
        'urls': url_status,
        'summary': await history.get_processing_needs(username)
    }
```

---

## ğŸ“‹ **ç•¶å‰æ­¥é©Ÿæ³¨æ„äº‹é …**

### **1. æ•¸æ“šåº«Schemaæ›´æ–°**
```sql
-- éœ€è¦æ–°å¢çš„æ¬„ä½
ALTER TABLE post_metrics_sql ADD COLUMN reader_status TEXT DEFAULT 'pending';
ALTER TABLE post_metrics_sql ADD COLUMN dom_status TEXT DEFAULT 'pending';  
ALTER TABLE post_metrics_sql ADD COLUMN reader_processed_at TIMESTAMPTZ;
ALTER TABLE post_metrics_sql ADD COLUMN dom_processed_at TIMESTAMPTZ;
```

### **2. å‘å¾Œå…¼å®¹æ€§**
```python
# ç¾æœ‰æ•¸æ“šçš„ç‹€æ…‹æ¨æ–·
def infer_status_from_existing(post: PostMetrics):
    if post.content and post.source in ['reader', 'jina']:
        post.reader_status = 'success'
    if post.is_complete and post.source in ['playwright', 'crawler']:
        post.dom_status = 'success'
```

### **3. é‡è¤‡è™•ç†é‚è¼¯**
```python
# æ™ºèƒ½å»é‡ï¼šç›¸åŒURLä½†ä¸åŒè™•ç†æ–¹å¼å¯ä»¥å…±å­˜
async def should_process(url: str, process_type: str) -> bool:
    existing = await get_post_by_url(url)
    if not existing:
        return True
        
    if process_type == 'reader':
        return existing.reader_status != 'success'
    elif process_type == 'dom':
        return existing.dom_status != 'success'
    
    return False
```

---

## ğŸ¯ **å¯¦æ–½å„ªå…ˆç´šå»ºè­°**

### **Phase 1ï¼šåŸºç¤ç‹€æ…‹è¿½è¹¤**
1. âœ… æ“´å±•PostMetricsæ¨¡å‹ï¼ˆæ–°å¢é›™è»Œç‹€æ…‹æ¬„ä½ï¼‰
2. âœ… ä¿®æ”¹æ•¸æ“šåº«schema  
3. âœ… æ›´æ–°upserté‚è¼¯æ”¯æ´ç‹€æ…‹æ›´æ–°

### **Phase 2ï¼šURLç‹€æ…‹æŸ¥è©¢**
1. âœ… å¯¦ç¾get_posts_status()æ–¹æ³•
2. âœ… ä¿®æ”¹URLæ”¶é›†å™¨è¿”å›ç‹€æ…‹ä¿¡æ¯
3. âœ… å‰µå»ºè™•ç†éœ€æ±‚åˆ†æAPI

### **Phase 3ï¼šUIæ•´åˆ**
1. ğŸ”„ å‰ç«¯ç‹€æ…‹é¡¯ç¤ºçµ„ä»¶
2. ğŸ”„ æ‰¹é‡æ“ä½œç•Œé¢
3. ğŸ”„ å¯¦æ™‚ç‹€æ…‹æ›´æ–°

**éœ€è¦æˆ‘é–‹å§‹å¯¦æ–½Phase 1å—ï¼Ÿé‚„æ˜¯ä½ æƒ³å…ˆç¢ºèªæŸå€‹å…·é«”çš„è¨­è¨ˆç´°ç¯€ï¼Ÿ**